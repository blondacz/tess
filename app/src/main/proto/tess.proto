syntax = "proto3";

package dev.g4s.tess.raft.v1;

option java_multiple_files = true;
option java_package = "dev.g4s.tess.raft.v1";
option java_outer_classname = "TessRaftProto";
import "scalapb/scalapb.proto";

// ==============================
// Core Domain Types
// ==============================

message ActorKey {
  option (scalapb.message).no_box = true;
  string actor_type = 1;
  int64 actor_id = 2;
}

message EventEnvelope {
  // Fully qualified class name or logical type of the event, e.g. "dev.g4s.tess.OrderCreated"
  string event_type = 1;

  // Serialized event payload (e.g., CBOR/JSON/Protobuf for the specific event)
  bytes payload = 2;
}

// Mirror of dev.g4s.tess.ActorUnitOfWork
// A batch of events for a single actor, generated by one Actor#receive.
message ActorUnitOfWork {
  ActorKey key = 1;

  // Version of the actor before applying this UoW
  int64 actor_version = 2;

  // Global reaction rank of the first reaction in this UoW
  int64 starting_reaction_rank = 3;

  // Reactions in this UoW; ending_reaction_rank can be derived as starting + reactions.size - 1
  repeated EventEnvelope events = 4; // legacy name; holds all reactions serialized as events/notifications/commands
}

// ==============================
// RocksDB: Actor Event Storage (actors CF)
// ==============================
//
//
//   a:<actorType>:<actorId>:<startingReactionRank>
//
// If you want a more granular, per-event record, you can use this:

message ActorEventRecord {
  ActorKey key = 1;

  // Global event rank for this specific event
  int64 event_rank = 2;

  // True if this record represents a snapshot instead of a plain event.
  bool is_snapshot = 3;

  // Actor version at this event (or at snapshot)
  int64 actor_version = 4;

  // The actual event or snapshot payload
  EventEnvelope event = 5;
}

// ==============================
// Raft Wire Format (for gRPC) - Full Entries
// ==============================

message RaftLogEntryWire {
  int64 term = 1;
  int64 index = 2;
  int64 starting_reaction_rank = 3;
  int64 ending_reaction_rank = 4;
  repeated ActorUnitOfWork actor_units = 5;
}

// ==============================
// RocksDB: Lightweight Log Index (raft-log CF)
// ==============================
//
// After receiving RaftLogEntryWire, Events projected into the `actors` CF,
// and only minimal index entry in stored `raft-log` CF that just points at them.

// Pointer to a contiguous block of event ranks for one actor.
// Matches (ActorKey, [start..end]) in  model.
message LogActorPointer {
  ActorKey actor_key = 1;
  int64 starting_reaction_rank = 2;
  int64 ending_reaction_rank = 3;
}

//   r:<group_id>:<log_index> => RaftLogIndexEntry
message RaftLogIndexEntry {
  string group_id = 1;
  int64 term = 2;
  int64 index = 3;

  // Pointers to events that were projected into the `actors` CF
  repeated LogActorPointer actor_pointers = 4;
}

// ==============================
// Raft Metadata (raft-meta CF)
// ==============================

message RaftMeta {
  string group_id = 1;        // e.g. "main" or shard id
  int64 current_term = 2;
  string voted_for = 3;       // node id (or empty)
  int64 commit_index = 4;
  int64 last_applied = 5;
}

// ==============================
// Raft RPC Messages (gRPC)
// ==============================

// IDs for nodes & groups
message NodeId {
  string id = 1;
}

message GroupId {
  string id = 1;
}

// ---- RequestVote ----

message RequestVoteRequest {
  GroupId group_id = 1;
  NodeId candidate_id = 2;
  int64 term = 3;

  // Candidate's last log index and term
  int64 last_log_index = 4;
  int64 last_log_term = 5;
}

message RequestVoteResponse {
  int64 term = 1;
  bool vote_granted = 2;
}

// ---- AppendEntries ----

message AppendEntriesRequest {
  GroupId group_id = 1;
  NodeId leader_id = 2;
  int64 term = 3;

  // Index + term of log entry immediately preceding new ones
  int64 prev_log_index = 4;
  int64 prev_log_term = 5;

  // Entries to store (empty for heartbeat)
  repeated RaftLogEntryWire entries = 6;

  // Leaderâ€™s commit index
  int64 leader_commit = 7;
}

message AppendEntriesResponse {
  int64 term = 1;

  // True if follower contained entry matching prev_log_index and prev_log_term
  bool success = 2;

  // Highest log index known to be replicated on this follower
  // (for fast catch-up / matchIndex advancement)
  int64 match_index = 3;
}

// ---- InstallSnapshot (optional but typical for Raft) ----

message InstallSnapshotRequest {
  GroupId group_id = 1;
  NodeId leader_id = 2;
  int64 term = 3;

  int64 last_included_index = 4;
  int64 last_included_term = 5;

  // Arbitrary snapshot payload (e.g., your own snapshot format)
  bytes snapshot = 6;
}

message InstallSnapshotResponse {
  int64 term = 1;
}

// ==============================
// Raft gRPC Service
// ==============================

service Raft {
  rpc RequestVote(RequestVoteRequest) returns (RequestVoteResponse);
  rpc AppendEntries(AppendEntriesRequest) returns (AppendEntriesResponse);
  rpc InstallSnapshot(InstallSnapshotRequest) returns (InstallSnapshotResponse);
}
